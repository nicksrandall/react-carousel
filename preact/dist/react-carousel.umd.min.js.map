{"version":3,"file":"react-carousel.umd.min.js","sources":["../../src/utils.js","../../src/carousel.js","../../src/index.js"],"sourcesContent":["export function noop() {}\n\n/**\n * Takes an argument and if it's an array, returns the first item in the array\n * otherwise returns the argument\n * @param {*} arg the maybe-array\n * @param {*} defaultValue the value if arg is falsey not defined\n * @return {*} the arg or it's first item\n */\nexport function unwrapArray(arg, defaultValue) {\n  arg = Array.isArray(arg) ? /* istanbul ignore next (preact) */ arg[0] : arg\n  if (!arg && defaultValue) {\n    return defaultValue\n  } else {\n    return arg\n  }\n}\n\n/**\n * This is intended to be used to compose event handlers\n * They are executed in order until one of them calls\n * `event.preventDefault()`. Not sure this is the best\n * way to do this, but it seems legit...\n * @param {Function} fns the event handler functions\n * @return {Function} the event handler to add to an element\n */\nexport function composeEventHandlers(...fns) {\n  return (event, ...args) => {\n    fns.forEach(fn => {\n      fn && fn(event, ...args);\n    })\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport {unwrapArray, noop, composeEventHandlers} from './utils'\n\nconst clock = typeof performance === \"object\" && performance.now ? performance : Date;\n\nclass Carousel extends React.Component {\n  static propTypes = {\n    children: PropTypes.func,\n    render: PropTypes.func,\n    animationDuration: PropTypes.number,\n    calculateWidth: PropTypes.func,\n    dynamicSizes: PropTypes.bool,\n    slideDuration: PropTypes.number,\n    slideCount: PropTypes.number.isRequired,\n    autoPlay: PropTypes.bool,\n  }\n  static defaultProps = {\n    animationDuration: 250,\n    slideDuration: 0,\n    calculateWidth: context => context._windowRef.offsetWidth,\n    dynamicSizes: false,\n    autoPlay: true,\n  }\n  constructor(props) {\n    super(props)\n    this.state = {\n      focused: true,\n      prevIndex: this.props.slideCount - 1,\n      currentIndex: 0,\n      nextIndex: 1,\n      finalPrevIndex: this.props.slideCount - 1,\n      finalCurrentIndex: 0,\n      finalNextIndex: 1,\n      windowWidth: 0,\n      trackWidth: 0,\n      dragOffset: 0,\n      transitionDirection: 1,\n    }\n    this.running = false\n  }\n  calculateSizes = () => {\n    this.setState({\n      windowWidth: this._windowRef.offsetWidth,\n      trackWidth: this._windowRef.offsetWidth * 3,\n    })\n  }\n  componentDidMount() {\n    this.calculateSizes()\n    window.addEventListener('resize', this.resize, false)\n    document.addEventListener(\n      'visibilitychange',\n      this.handleVisibilityChange,\n      false,\n    )\n    document.addEventListener('keydown', this.keydown, false)\n\n    if (this.props.autoPlay) {\n      this.now = clock.now();\n      this.play()\n    }\n  }\n  play = () => {\n    if (this.state.focused) {\n      this.timeout = setTimeout(() => {\n        this.goToSlide(this.nextIndex(this.state.currentIndex))\n      }, this.props.slideDuration)\n    }\n  }\n  pause = () => {\n    clearTimeout(this.timeout)\n  }\n  resize = () => {\n    if (this.running) {\n      return\n    }\n    this.running = true\n    window.requestAnimationFrame(() => {\n      this.calculateSizes()\n      this.running = false\n    })\n  }\n  handleVisibilityChange = () => {\n    this.setState({focused: !document.hidden}, () => {\n      document.hidden ? this.pause() : this.props.autoPlay && this.play()\n    })\n  }\n  keydown = e => {\n    if (e.keyCode === 37) {\n      // previous\n      this.goToSlide(this.prevIndex(this.state.currentIndex), true)\n    }\n    if (e.keyCode === 39) {\n      // next\n      this.goToSlide(this.nextIndex(this.state.currentIndex), true)\n    }\n  }\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.resize, false)\n    document.removeEventListener(\n      'visibilitychange',\n      this.handleVisibilityChange,\n      false,\n    )\n    document.removeEventListener('keydown', this.keydown, false)\n  }\n  commitUpdate = () => {\n    this.setState({\n      finalPrevIndex: this.state.prevIndex,\n      finalCurrentIndex: this.state.currentIndex,\n      finalNextIndex: this.state.nextIndex,\n    })\n  }\n  goToSlide = (index, jump = false) => {\n    this.pause()\n    this.now = clock.now();\n\n    let transitionDirection = 1\n    if (\n      index > this.state.currentIndex ||\n      (index === 0 && this.state.currentIndex === this.props.slideCount - 1)\n    ) {\n      transitionDirection = 2\n    } else if (\n      index < this.state.currentIndex ||\n      (this.state.currentIndex === 0 && index === this.props.slideCount - 1)\n    ) {\n      transitionDirection = 0\n    }\n\n    let animationMS =\n      Math.abs(\n        this.state.windowWidth +\n          this.state.dragOffset -\n          this.state.windowWidth * transitionDirection,\n      ) *\n      this.props.animationDuration /\n      this.state.windowWidth\n\n    if (this.props.animationDuration <= 0) {\n      this.commitUpdate()\n    }\n\n    let prevIndex = this.prevIndex(index)\n    let currentIndex = index\n    let nextIndex = this.nextIndex(index)\n\n    if (jump) {\n      switch (transitionDirection) {\n        case 0:\n          this.setState({finalPrevIndex: index})\n          break\n        case 2:\n          this.setState({finalNextIndex: index})\n          break\n      }\n    }\n\n    this.setState(\n      {\n        transitionDirection,\n        animationMS,\n        prevIndex,\n        currentIndex,\n        nextIndex,\n      },\n      () => {\n        if (this.props.autoPlay) {\n          this.play()\n        }\n      },\n    )\n  }\n  prevIndex = index => {\n    return index > 0 ? index - 1 : this.props.slideCount - 1\n  }\n  nextIndex = index => {\n    return index < this.props.slideCount - 1 ? index + 1 : 0\n  }\n  getRootProps = ({...rest} = {}) => {\n    return {\n      ...rest,\n    }\n  }\n  windowRef = node => (this._windowRef = node)\n  getWindowProps = ({refKey = 'ref', ...rest} = {}) => {\n    return {\n      [refKey]: this.windowRef,\n      ...rest,\n    }\n  }\n  trackRef = node => (this._trackRef = node)\n  track_handleTransitionEnd = () => {\n    this.commitUpdate()\n    this.setState({animationMS: 0, transitionDirection: 1})\n  }\n  getTrackProps = ({refKey = 'ref', onTransitionEnd, style, ...rest} = {}) => {\n    return {\n      [refKey]: this.trackRef,\n      style: {\n        ...style,\n        width: this.state.trackWidth,\n        transition:\n          this.state.animationMS > 0\n            ? `transform ${this.state.animationMS}ms`\n            : null,\n        transform: `translate3d(-${this.state.windowWidth *\n          this.state.transitionDirection +\n          this.state.dragOffset}px, 0px, 0px)`,\n      },\n      onTransitionEnd: composeEventHandlers(\n        onTransitionEnd,\n        this.track_handleTransitionEnd,\n      ),\n      ...rest,\n    }\n  }\n  slide_handleSwipeStart = e => {\n    const posX = e.touches !== undefined ? e.touches[0].pageX : e.clientX\n    this.setState({\n      dragging: true,\n      touchObject: {\n        startX: posX,\n        curX: posX,\n      },\n    })\n  }\n  slide_handleSwipeMove = e => {\n    const touchObject = this.state.touchObject\n    touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX\n    let dragOffset =\n      Math.round(\n        Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)),\n      ) * (touchObject.curX > touchObject.startX ? -1 : 1)\n    this.setState({dragOffset, touchObject})\n  }\n  slide_handleSwipeEnd = () => {\n    if (this.state.dragOffset > 100) {\n      this.goToSlide(this.nextIndex(this.state.currentIndex))\n    } else if (this.state.dragOffset < -100) {\n      this.goToSlide(this.prevIndex(this.state.currentIndex))\n    }\n    this.setState({\n      dragging: false,\n      dragOffset: 0,\n      touchObject: {\n        startX: 0,\n        curX: 0,\n      },\n    })\n  }\n  getNextSlideProps = ({style, ...rest} = {}) => {\n    return {\n      key: this.state.finalNextIndex,\n      'data-index': this.state.finalNextIndex,\n      style: {\n        ...style,\n        width: this.state.windowWidth,\n      },\n      ...rest,\n    }\n  }\n  getCurrentSlideProps = ({\n    onMouseDown,\n    onMouseMove,\n    onMouseUp,\n    onMouseLeave,\n    style,\n    ...rest\n  } = {}) => {\n    return {\n      key: this.state.finalCurrentIndex,\n      'data-index': this.state.finalCurrentIndex,\n      onMouseDown: composeEventHandlers(\n        this.slide_handleSwipeStart,\n        onMouseDown,\n      ),\n      onMouseMove: composeEventHandlers(\n        this.state.dragging ? this.slide_handleSwipeMove : null,\n        onMouseMove,\n      ),\n      onMouseUp: composeEventHandlers(this.slide_handleSwipeEnd, onMouseUp),\n      onMouseLeave: composeEventHandlers(\n        this.state.dragging ? this.slide_handleSwipeEnd : null,\n        onMouseLeave,\n      ),\n      style: {\n        ...style,\n        width: this.state.windowWidth,\n      },\n      ...rest,\n    }\n  }\n  getPrevSlideProps = ({style, ...rest} = {}) => {\n    return {\n      key: this.state.finalPrevIndex,\n      'data-index': this.state.finalPrevIndex,\n      style: {\n        ...style,\n        width: this.state.windowWidth,\n      },\n      ...rest,\n    }\n  }\n  prevButton_handleClick = () => {\n    this.goToSlide(this.prevIndex(this.state.currentIndex))\n  }\n  getPrevButtonProps = ({onClick, ...rest} = {}) => {\n    return {\n      type: 'button',\n      'data-role': 'none',\n      onClick: composeEventHandlers(onClick, this.prevButton_handleClick),\n      ...rest,\n    }\n  }\n  nextButton_handleClick = () => {\n    this.goToSlide(this.nextIndex(this.state.currentIndex))\n  }\n  getNextButtonProps = ({onClick, ...rest} = {}) => {\n    return {\n      type: 'button',\n      'data-role': 'none',\n      onClick: composeEventHandlers(onClick, this.nextButton_handleClick),\n      ...rest,\n    }\n  }\n  getIndicatorListProps = ({...rest} = {}) => {\n    return {\n      ...rest,\n    }\n  }\n  indicator_makeHandleClick = idx => () => {\n    this.goToSlide(idx, true)\n  }\n  getIndicatorProps = ({onClick, index, ...rest} = {}) => {\n    return {\n      tabindex: index === this.state.currentIndex ? '-1' : null,\n      onClick: composeEventHandlers(\n        onClick,\n        this.indicator_makeHandleClick(index),\n      ),\n      ...rest,\n    }\n  }\n  getStateAndHelpers() {\n    const {\n      getRootProps,\n      getWindowProps,\n      getTrackProps,\n      getPrevSlideProps,\n      getCurrentSlideProps,\n      getNextSlideProps,\n      getPrevButtonProps,\n      getNextButtonProps,\n      getIndicatorListProps,\n      getIndicatorProps,\n\n      goToSlide,\n      nextIndex,\n      prevIndex,\n    } = this\n    return {\n      // props\n      getRootProps,\n      getWindowProps,\n      getTrackProps,\n      getPrevSlideProps,\n      getCurrentSlideProps,\n      getNextSlideProps,\n      getPrevButtonProps,\n      getNextButtonProps,\n      getIndicatorListProps,\n      getIndicatorProps,\n\n      // fnunctional helpers\n      goToSlide,\n      getNextIndex: nextIndex,\n      getPrevIndex: prevIndex,\n\n      // state helpers\n      dragOffset: this.state.dragOffset,\n      slideCount: this.props.slideCount,\n      finalPrevIndex: this.state.finalPrevIndex,\n      finalCurrentIndex: this.state.finalCurrentIndex,\n      finalNextIndex: this.state.finalNextIndex,\n      prevIndex: this.state.prevIndex,\n      currentIndex: this.state.currentIndex,\n      nextIndex: this.state.nextIndex,\n\n      // can be used by indicators to show progress\n      startTime: this.now\n    }\n  }\n  render() {\n    const children = unwrapArray(this.props.render || this.props.children, noop)\n    const element = unwrapArray(children(this.getStateAndHelpers()))\n    if (!element) {\n      return null\n    }\n    return element\n  }\n}\n\nexport default Carousel\n","import Carousel from './carousel'\n\nCarousel.default = Carousel\n\nexport default Carousel\n"],"names":["noop","unwrapArray","arg","defaultValue","Array","isArray","composeEventHandlers","fns","event","args","forEach","fn","clock","performance","now","Date","Carousel","props","_React$Component","calculateSizes","setState","_this","_windowRef","offsetWidth","play","state","focused","timeout","setTimeout","goToSlide","nextIndex","currentIndex","slideDuration","pause","resize","running","requestAnimationFrame","handleVisibilityChange","document","hidden","autoPlay","keydown","e","keyCode","prevIndex","commitUpdate","index","jump","transitionDirection","slideCount","animationMS","Math","abs","windowWidth","dragOffset","animationDuration","finalPrevIndex","finalNextIndex","getRootProps","rest","windowRef","node","getWindowProps","refKey","trackRef","_trackRef","track_handleTransitionEnd","getTrackProps","onTransitionEnd","style","trackWidth","slide_handleSwipeStart","posX","undefined","touches","pageX","clientX","slide_handleSwipeMove","touchObject","curX","round","sqrt","pow","startX","slide_handleSwipeEnd","getNextSlideProps","getCurrentSlideProps","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","finalCurrentIndex","dragging","getPrevSlideProps","prevButton_handleClick","getPrevButtonProps","onClick","nextButton_handleClick","getNextButtonProps","getIndicatorListProps","indicator_makeHandleClick","idx","getIndicatorProps","componentDidMount","addEventListener","this","componentWillUnmount","removeEventListener","getStateAndHelpers","render","element","children","React","Component","defaultProps","context","default"],"mappings":"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"}